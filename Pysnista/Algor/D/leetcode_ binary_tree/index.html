<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Leetcode - Linked lists  | Pinsflora</title><meta name="description" content="Leetcode - Linked lists"><meta name="keywords" content="Python,Leetcode"><meta name="author" content="Joaxin"><meta name="copyright" content="Joaxin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://u.pinsflora.com/Pysnista/Algor/D/leetcode_%20binary_tree/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Leetcode - Linked lists "><meta property="og:url" content="https://u.pinsflora.com/Pysnista/Algor/D/leetcode_%20binary_tree/"><meta property="og:site_name" content="Pinsflora"><meta property="og:description" content="Leetcode - Linked lists"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/joaxin/img_bed/img/cover/cover_stars_man_orchard_photos.jpg"><meta property="article:published_time" content="2018-01-13T16:00:00.000Z"><meta property="article:modified_time" content="2018-12-16T16:00:00.000Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-177831205-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-177831205-1');
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime: 'days',
  date_suffix: {"one_hour":"Just","hours":"hours ago","day":"days ago"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2018-12-17 00:00:00'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="Pinsflora" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://avatars2.githubusercontent.com/u/8346164?s=460&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">273</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">99</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">34</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-file-image-o"></i><span> Galleries</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Games</span></a></li><li><a class="site-page" href="/tools/"><i class="fa-fw fas fa-wrench"></i><span> Tools</span></a></li></ul></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#traversal"><span class="toc-number">1.</span> <span class="toc-text"> Traversal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#94-binary-tree-inorder-traversalm"><span class="toc-number">1.1.</span> <span class="toc-text"> 94. Binary Tree Inorder Traversal[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description"><span class="toc-number">1.1.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution"><span class="toc-number">1.1.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#145-binary-tree-postorder-traversalsh"><span class="toc-number">1.2.</span> <span class="toc-text"> 145. Binary Tree Postorder Traversals[H]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-2"><span class="toc-number">1.2.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-2"><span class="toc-number">1.2.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-binary-tree-preorder-traversalm"><span class="toc-number">1.3.</span> <span class="toc-text"> 144. Binary Tree Preorder Traversal[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-3"><span class="toc-number">1.3.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-3"><span class="toc-number">1.3.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-binary-tree-level-order-traversalm"><span class="toc-number">1.4.</span> <span class="toc-text"> 102. Binary Tree Level Order Traversal[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-4"><span class="toc-number">1.4.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-4"><span class="toc-number">1.4.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103-binary-tree-zigzag-level-order-traversalm"><span class="toc-number">1.5.</span> <span class="toc-text"> 103. Binary Tree Zigzag Level Order Traversal[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-5"><span class="toc-number">1.5.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-5"><span class="toc-number">1.5.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-construct-binary-tree-from-preorder-and-inorder-traversalm"><span class="toc-number">1.6.</span> <span class="toc-text"> 105. Construct Binary Tree from Preorder and Inorder Traversal[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-6"><span class="toc-number">1.6.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-6"><span class="toc-number">1.6.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#106-construct-binary-tree-from-inorder-and-postorder-traversalm"><span class="toc-number">1.7.</span> <span class="toc-text"> 106. Construct Binary Tree from Inorder and Postorder Traversal[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-7"><span class="toc-number">1.7.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-7"><span class="toc-number">1.7.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#107-binary-tree-level-order-traversal-iie"><span class="toc-number">1.8.</span> <span class="toc-text"> 107. Binary Tree Level Order Traversal II[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-8"><span class="toc-number">1.8.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-8"><span class="toc-number">1.8.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unique"><span class="toc-number">2.</span> <span class="toc-text"> Unique</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#95-unique-binary-search-trees-iim"><span class="toc-number">2.1.</span> <span class="toc-text"> 95. Unique Binary Search Trees II[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-9"><span class="toc-number">2.1.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-9"><span class="toc-number">2.1.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-unique-binary-search-treesm"><span class="toc-number">2.2.</span> <span class="toc-text"> 96. Unique Binary Search Trees[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-10"><span class="toc-number">2.2.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-10"><span class="toc-number">2.2.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#99-recover-binary-search-treeh"><span class="toc-number">2.3.</span> <span class="toc-text"> 99. Recover Binary Search Tree[H]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-11"><span class="toc-number">2.3.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-11"><span class="toc-number">2.3.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-validate-binary-search-treem"><span class="toc-number">2.4.</span> <span class="toc-text"> 98. Validate Binary Search Tree[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-12"><span class="toc-number">2.4.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-12"><span class="toc-number">2.4.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#100-same-treee"><span class="toc-number">2.5.</span> <span class="toc-text"> 100. Same Tree[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-13"><span class="toc-number">2.5.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-13"><span class="toc-number">2.5.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#depth"><span class="toc-number">3.</span> <span class="toc-text"> Depth</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#104-maximum-depth-of-binary-treee"><span class="toc-number">3.1.</span> <span class="toc-text"> 104. Maximum Depth of Binary Tree[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-14"><span class="toc-number">3.1.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-14"><span class="toc-number">3.1.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#111-minimum-depth-of-binary-treee"><span class="toc-number">3.2.</span> <span class="toc-text"> 111. Minimum Depth of Binary Tree[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-15"><span class="toc-number">3.2.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-15"><span class="toc-number">3.2.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#convert"><span class="toc-number">4.</span> <span class="toc-text"> Convert</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#108-convert-sorted-array-to-binary-search-treee"><span class="toc-number">4.1.</span> <span class="toc-text"> 108. Convert Sorted Array to Binary Search Tree[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-16"><span class="toc-number">4.1.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-16"><span class="toc-number">4.1.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#109-convert-sorted-list-to-binary-search-treem"><span class="toc-number">4.2.</span> <span class="toc-text"> 109. Convert Sorted List to Binary Search Tree[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-17"><span class="toc-number">4.2.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-17"><span class="toc-number">4.2.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-flatten-binary-tree-to-linked-listm"><span class="toc-number">4.3.</span> <span class="toc-text"> 114. Flatten Binary Tree to Linked List[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-18"><span class="toc-number">4.3.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-18"><span class="toc-number">4.3.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#110-balanced-binary-treee"><span class="toc-number">4.4.</span> <span class="toc-text"> 110. Balanced Binary Tree[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-19"><span class="toc-number">4.4.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-19"><span class="toc-number">4.4.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-binary-tree-maximum-path-sumh"><span class="toc-number">4.5.</span> <span class="toc-text"> 124. Binary Tree Maximum Path Sum[H]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-20"><span class="toc-number">4.5.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-20"><span class="toc-number">4.5.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-invert-binary-treee"><span class="toc-number">4.6.</span> <span class="toc-text"> 226. Invert Binary Tree[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-21"><span class="toc-number">4.6.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-21"><span class="toc-number">4.6.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#235-lowest-common-ancestor-of-a-binary-search-treee"><span class="toc-number">4.7.</span> <span class="toc-text"> 235. Lowest Common Ancestor of a Binary Search Tree[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-22"><span class="toc-number">4.7.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-22"><span class="toc-number">4.7.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-lowest-common-ancestor-of-a-binary-treem"><span class="toc-number">4.8.</span> <span class="toc-text"> 236. Lowest Common Ancestor of a Binary Tree[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-23"><span class="toc-number">4.8.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-23"><span class="toc-number">4.8.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#257-binary-tree-pathse"><span class="toc-number">4.9.</span> <span class="toc-text"> 257. Binary Tree Paths[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-24"><span class="toc-number">4.9.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-24"><span class="toc-number">4.9.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#543-diameter-of-binary-treee"><span class="toc-number">4.10.</span> <span class="toc-text"> 543. Diameter of Binary Tree[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-25"><span class="toc-number">4.10.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-25"><span class="toc-number">4.10.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#617-merge-two-binary-treese"><span class="toc-number">4.11.</span> <span class="toc-text"> 617. Merge Two Binary Trees[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-26"><span class="toc-number">4.11.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-26"><span class="toc-number">4.11.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#654-maximum-binary-treem"><span class="toc-number">4.12.</span> <span class="toc-text"> 654. Maximum Binary Tree[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-27"><span class="toc-number">4.12.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-27"><span class="toc-number">4.12.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#671-second-minimum-node-in-a-binary-treee"><span class="toc-number">4.13.</span> <span class="toc-text"> 671. Second Minimum Node In a Binary Tree[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-28"><span class="toc-number">4.13.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-28"><span class="toc-number">4.13.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#700-search-in-a-binary-search-treee"><span class="toc-number">4.14.</span> <span class="toc-text"> 700. Search in a Binary Search Tree[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-29"><span class="toc-number">4.14.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-29"><span class="toc-number">4.14.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-symmetric-treee"><span class="toc-number">4.15.</span> <span class="toc-text"> 101. Symmetric Tree[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-30"><span class="toc-number">4.15.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-30"><span class="toc-number">4.15.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#208-implement-trie-prefix-treem"><span class="toc-number">4.16.</span> <span class="toc-text"> 208. Implement Trie (Prefix Tree)[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-31"><span class="toc-number">4.16.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-31"><span class="toc-number">4.16.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#538-convert-bst-to-greater-treee"><span class="toc-number">4.17.</span> <span class="toc-text"> 538. Convert BST to Greater Tree[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-32"><span class="toc-number">4.17.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-32"><span class="toc-number">4.17.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#572-subtree-of-another-treee"><span class="toc-number">4.18.</span> <span class="toc-text"> 572. Subtree of Another Tree[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-33"><span class="toc-number">4.18.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-33"><span class="toc-number">4.18.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#872-leaf-similar-treese"><span class="toc-number">4.19.</span> <span class="toc-text"> 872. Leaf-Similar Trees[E]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-34"><span class="toc-number">4.19.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-34"><span class="toc-number">4.19.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#116-populating-next-right-pointers-in-each-nodem"><span class="toc-number">4.20.</span> <span class="toc-text"> 116. Populating Next Right Pointers in Each Node[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-35"><span class="toc-number">4.20.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-35"><span class="toc-number">4.20.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#117-populating-next-right-pointers-in-each-node-iim"><span class="toc-number">4.21.</span> <span class="toc-text"> 117. Populating Next Right Pointers in Each Node II[M]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#description-36"><span class="toc-number">4.21.1.</span> <span class="toc-text"> Description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solution-36"><span class="toc-number">4.21.2.</span> <span class="toc-text"> Solution</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/joaxin/img_bed/img/cover/cover_stars_man_orchard_photos.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Pinsflora</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-file-image-o"></i><span> Galleries</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> Games</span></a></li><li><a class="site-page" href="/tools/"><i class="fa-fw fas fa-wrench"></i><span> Tools</span></a></li></ul></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Leetcode - Linked lists </div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2018-01-13T16:00:00.000Z" title="Created 2018-01-14 00:00:00">2018-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2018-12-16T16:00:00.000Z" title="Updated 2018-12-17 00:00:00">2018-12-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/Leetcode/">Leetcode</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>30min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="traversal"><a class="markdownIt-Anchor" href="#traversal"></a> Traversal</h1>
<h2 id="94-binary-tree-inorder-traversalm"><a class="markdownIt-Anchor" href="#94-binary-tree-inorder-traversalm"></a> 94. Binary Tree Inorder Traversal[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/">https://leetcode.com/problems/binary-tree-inorder-traversal/</a></p>
<h3 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description</h3>
<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<h3 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/solution/">https://leetcode.com/problems/binary-tree-inorder-traversal/solution/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(curr, TreeNode):</span><br><span class="line">                res.append(curr)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> curr.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(curr.right)</span><br><span class="line">            stack.append(curr.val)</span><br><span class="line">            <span class="keyword">if</span> curr.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(curr.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h2 id="145-binary-tree-postorder-traversalsh"><a class="markdownIt-Anchor" href="#145-binary-tree-postorder-traversalsh"></a> 145. Binary Tree Postorder Traversals[H]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-postorder-traversal/">https://leetcode.com/problems/binary-tree-postorder-traversal/</a></p>
<h3 id="description-2"><a class="markdownIt-Anchor" href="#description-2"></a> Description</h3>
<p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<h3 id="solution-2"><a class="markdownIt-Anchor" href="#solution-2"></a> Solution</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []; stack = [root]</span><br><span class="line">        <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(curr, TreeNode):</span><br><span class="line">                res.append(curr)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            stack.append(curr.val)</span><br><span class="line">            <span class="keyword">if</span> curr.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(curr.right)</span><br><span class="line">            <span class="keyword">if</span> curr.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(curr.left)</span><br><span class="line">        <span class="keyword">return</span> res        </span><br></pre></td></tr></table></figure>
<h2 id="144-binary-tree-preorder-traversalm"><a class="markdownIt-Anchor" href="#144-binary-tree-preorder-traversalm"></a> 144. Binary Tree Preorder Traversal[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-preorder-traversal/">https://leetcode.com/problems/binary-tree-preorder-traversal/</a></p>
<h3 id="description-3"><a class="markdownIt-Anchor" href="#description-3"></a> Description</h3>
<p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<h3 id="solution-3"><a class="markdownIt-Anchor" href="#solution-3"></a> Solution</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># stack</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            res.append(curr.val)</span><br><span class="line">            <span class="keyword">if</span> curr.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(curr.right)</span><br><span class="line">            <span class="keyword">if</span> curr.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(curr.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="102-binary-tree-level-order-traversalm"><a class="markdownIt-Anchor" href="#102-binary-tree-level-order-traversalm"></a> 102. Binary Tree Level Order Traversal[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">https://leetcode.com/problems/binary-tree-level-order-traversal/</a></p>
<h3 id="description-4"><a class="markdownIt-Anchor" href="#description-4"></a> Description</h3>
<p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br />
Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="solution-4"><a class="markdownIt-Anchor" href="#solution-4"></a> Solution</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># https://leetcode.com/discuss/90680/9-lines-python-code</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q = [[root]]</span><br><span class="line">        <span class="keyword">for</span> level <span class="keyword">in</span> q:</span><br><span class="line">            record = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> level:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    record.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    record.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> record:</span><br><span class="line">                q.append(record)</span><br><span class="line">        <span class="keyword">return</span> [[x.val <span class="keyword">for</span> x <span class="keyword">in</span> level] <span class="keyword">for</span> level <span class="keyword">in</span> q]</span><br></pre></td></tr></table></figure>
<h2 id="103-binary-tree-zigzag-level-order-traversalm"><a class="markdownIt-Anchor" href="#103-binary-tree-zigzag-level-order-traversalm"></a> 103. Binary Tree Zigzag Level Order Traversal[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/</a></p>
<h3 id="description-5"><a class="markdownIt-Anchor" href="#description-5"></a> Description</h3>
<p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br />
Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>return its zigzag level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="solution-5"><a class="markdownIt-Anchor" href="#solution-5"></a> Solution</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="105-construct-binary-tree-from-preorder-and-inorder-traversalm"><a class="markdownIt-Anchor" href="#105-construct-binary-tree-from-preorder-and-inorder-traversalm"></a> 105. Construct Binary Tree from Preorder and Inorder Traversal[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/divide-two-integers/">https://leetcode.com/problems/divide-two-integers/</a></p>
<h3 id="description-6"><a class="markdownIt-Anchor" href="#description-6"></a> Description</h3>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br />
You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>
<p>Return the following binary tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<h3 id="solution-6"><a class="markdownIt-Anchor" href="#solution-6"></a> Solution</h3>
<h2 id="106-construct-binary-tree-from-inorder-and-postorder-traversalm"><a class="markdownIt-Anchor" href="#106-construct-binary-tree-from-inorder-and-postorder-traversalm"></a> 106. Construct Binary Tree from Inorder and Postorder Traversal[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p>
<h3 id="description-7"><a class="markdownIt-Anchor" href="#description-7"></a> Description</h3>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br />
You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>
<p>Return the following binary tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<h3 id="solution-7"><a class="markdownIt-Anchor" href="#solution-7"></a> Solution</h3>
<h2 id="107-binary-tree-level-order-traversal-iie"><a class="markdownIt-Anchor" href="#107-binary-tree-level-order-traversal-iie"></a> 107. Binary Tree Level Order Traversal II[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">https://leetcode.com/problems/binary-tree-level-order-traversal-ii/</a></p>
<h3 id="description-8"><a class="markdownIt-Anchor" href="#description-8"></a> Description</h3>
<p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br />
Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="solution-8"><a class="markdownIt-Anchor" href="#solution-8"></a> Solution</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># use stack</span></span><br><span class="line">        stack = [[root]]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            top = stack.pop()</span><br><span class="line">            res.insert(<span class="number">0</span>, [t.val <span class="keyword">for</span> t <span class="keyword">in</span> top])</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> top:</span><br><span class="line">                <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    temp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    temp.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> len(temp) &gt; <span class="number">0</span>:</span><br><span class="line">                stack.append(temp)</span><br><span class="line">        <span class="keyword">return</span> res       </span><br></pre></td></tr></table></figure>
<h1 id="unique"><a class="markdownIt-Anchor" href="#unique"></a> Unique</h1>
<h2 id="95-unique-binary-search-trees-iim"><a class="markdownIt-Anchor" href="#95-unique-binary-search-trees-iim"></a> 95. Unique Binary Search Trees II[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees-ii/">https://leetcode.com/problems/unique-binary-search-trees-ii/</a></p>
<h3 id="description-9"><a class="markdownIt-Anchor" href="#description-9"></a> Description</h3>
<p>iven an integer <code>n</code>, generate all structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&#39;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 8</code></li>
</ul>
<h3 id="solution-9"><a class="markdownIt-Anchor" href="#solution-9"></a> Solution</h3>
<h2 id="96-unique-binary-search-treesm"><a class="markdownIt-Anchor" href="#96-unique-binary-search-treesm"></a> 96. Unique Binary Search Trees[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees/">https://leetcode.com/problems/unique-binary-search-trees/</a></p>
<h3 id="description-10"><a class="markdownIt-Anchor" href="#description-10"></a> Description</h3>
<p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>?</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n &#x3D; 3, there are a total of 5 unique BST&#39;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
<h3 id="solution-10"><a class="markdownIt-Anchor" href="#solution-10"></a> Solution</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/discuss/86650/fantastic-clean-java-dp-solution-with-detail-explaination">https://leetcode.com/discuss/86650/fantastic-clean-java-dp-solution-with-detail-explaination</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> level <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> range(<span class="number">1</span>, level + <span class="number">1</span>):</span><br><span class="line">                dp[level] += dp[level - root] * dp[root - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h2 id="99-recover-binary-search-treeh"><a class="markdownIt-Anchor" href="#99-recover-binary-search-treeh"></a> 99. Recover Binary Search Tree[H]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/recover-binary-search-tree/">https://leetcode.com/problems/recover-binary-search-tree/</a></p>
<h3 id="description-11"><a class="markdownIt-Anchor" href="#description-11"></a> Description</h3>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  &#x2F;</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">Output: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  3</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong></p>
<ul>
<li>A solution using O(<em>n</em>) space is pretty straight forward.</li>
<li>Could you devise a constant space solution?</li>
</ul>
<h3 id="solution-11"><a class="markdownIt-Anchor" href="#solution-11"></a> Solution</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="98-validate-binary-search-treem"><a class="markdownIt-Anchor" href="#98-validate-binary-search-treem"></a> 98. Validate Binary Search Tree[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-binary-search-tree/">https://leetcode.com/problems/validate-binary-search-tree/</a></p>
<h3 id="description-12"><a class="markdownIt-Anchor" href="#description-12"></a> Description</h3>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">Input: [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line"></span><br><span class="line">Input: [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&#39;s value is 5 but its right child&#39;s value is 4.</span><br></pre></td></tr></table></figure>
<h3 id="solution-12"><a class="markdownIt-Anchor" href="#solution-12"></a> Solution</h3>
<h2 id="100-same-treee"><a class="markdownIt-Anchor" href="#100-same-treee"></a> 100. Same Tree[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/same-tree/">https://leetcode.com/problems/same-tree/</a></p>
<h3 id="description-13"><a class="markdownIt-Anchor" href="#description-13"></a> Description</h3>
<p>Given two binary trees, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br></pre></td></tr></table></figure>
<h3 id="solution-13"><a class="markdownIt-Anchor" href="#solution-13"></a> Solution</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/same-tree/solution/">https://leetcode.com/problems/same-tree/solution/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p: TreeNode, q: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">None</span> <span class="keyword">and</span> q == <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> p != <span class="literal">None</span> <span class="keyword">and</span> q != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.val != q.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isSameTree(p.left, q.left): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span>  self.isSameTree(p.right, q.right)           </span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">q</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(p) === <span class="built_in">JSON</span>.stringify(q)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="depth"><a class="markdownIt-Anchor" href="#depth"></a> Depth</h1>
<h2 id="104-maximum-depth-of-binary-treee"><a class="markdownIt-Anchor" href="#104-maximum-depth-of-binary-treee"></a> 104. Maximum Depth of Binary Tree[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p>
<h3 id="description-14"><a class="markdownIt-Anchor" href="#description-14"></a> Description</h3>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>return its depth = 3.</p>
<h3 id="solution-14"><a class="markdownIt-Anchor" href="#solution-14"></a> Solution</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">         <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ld = self.maxDepth(root.left)</span><br><span class="line">        rd = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(ld, rd)</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
<h2 id="111-minimum-depth-of-binary-treee"><a class="markdownIt-Anchor" href="#111-minimum-depth-of-binary-treee"></a> 111. Minimum Depth of Binary Tree[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">https://leetcode.com/problems/minimum-depth-of-binary-tree/</a></p>
<h3 id="description-15"><a class="markdownIt-Anchor" href="#description-15"></a> Description</h3>
<p>ven a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<h3 id="solution-15"><a class="markdownIt-Anchor" href="#solution-15"></a> Solution</h3>
<h1 id="convert"><a class="markdownIt-Anchor" href="#convert"></a> Convert</h1>
<h2 id="108-convert-sorted-array-to-binary-search-treee"><a class="markdownIt-Anchor" href="#108-convert-sorted-array-to-binary-search-treee"></a> 108. Convert Sorted Array to Binary Search Tree[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</a></p>
<h3 id="description-16"><a class="markdownIt-Anchor" href="#description-16"></a> Description</h3>
<p>ven an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted array: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>
<h3 id="solution-16"><a class="markdownIt-Anchor" href="#solution-16"></a> Solution</h3>
<h2 id="109-convert-sorted-list-to-binary-search-treem"><a class="markdownIt-Anchor" href="#109-convert-sorted-list-to-binary-search-treem"></a> 109. Convert Sorted List to Binary Search Tree[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/</a></p>
<h3 id="description-17"><a class="markdownIt-Anchor" href="#description-17"></a> Description</h3>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted linked list: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>
<h3 id="solution-17"><a class="markdownIt-Anchor" href="#solution-17"></a> Solution</h3>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="114-flatten-binary-tree-to-linked-listm"><a class="markdownIt-Anchor" href="#114-flatten-binary-tree-to-linked-listm"></a> 114. Flatten Binary Tree to Linked List[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">https://leetcode.com/problems/flatten-binary-tree-to-linked-list/</a></p>
<h3 id="description-18"><a class="markdownIt-Anchor" href="#description-18"></a> Description</h3>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example, given the following tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>
<p>The flattened tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>
<h3 id="solution-18"><a class="markdownIt-Anchor" href="#solution-18"></a> Solution</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="110-balanced-binary-treee"><a class="markdownIt-Anchor" href="#110-balanced-binary-treee"></a> 110. Balanced Binary Tree[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/">https://leetcode.com/problems/balanced-binary-tree/</a></p>
<h3 id="description-19"><a class="markdownIt-Anchor" href="#description-19"></a> Description</h3>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<blockquote>
<p>a binary tree in which the left and right subtrees of <em>every</em> node differ in height by no more than 1.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>Return true.</p>
<p><strong>Example 2:</strong></p>
<p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>
<p>Return false.</p>
<h3 id="solution-19"><a class="markdownIt-Anchor" href="#solution-19"></a> Solution</h3>
<h2 id="124-binary-tree-maximum-path-sumh"><a class="markdownIt-Anchor" href="#124-binary-tree-maximum-path-sumh"></a> 124. Binary Tree Maximum Path Sum[H]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">https://leetcode.com/problems/binary-tree-maximum-path-sum/</a></p>
<h3 id="description-20"><a class="markdownIt-Anchor" href="#description-20"></a> Description</h3>
<p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure>
<h3 id="solution-20"><a class="markdownIt-Anchor" href="#solution-20"></a> Solution</h3>
<h2 id="226-invert-binary-treee"><a class="markdownIt-Anchor" href="#226-invert-binary-treee"></a> 226. Invert Binary Tree[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/invert-binary-tree/">https://leetcode.com/problems/invert-binary-tree/</a></p>
<h3 id="description-21"><a class="markdownIt-Anchor" href="#description-21"></a> Description</h3>
<p>Invert a binary tree.</p>
<p><strong>Example:</strong></p>
<p>Input:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<p><strong>Trivia:</strong><br />
This problem was inspired by <a target="_blank" rel="noopener" href="https://twitter.com/mxcl/status/608682016205344768">this original tweet</a> by <a target="_blank" rel="noopener" href="https://twitter.com/mxcl">Max Howell</a>:</p>
<blockquote>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p>
</blockquote>
<h3 id="solution-21"><a class="markdownIt-Anchor" href="#solution-21"></a> Solution</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="235-lowest-common-ancestor-of-a-binary-search-treee"><a class="markdownIt-Anchor" href="#235-lowest-common-ancestor-of-a-binary-search-treee"></a> 235. Lowest Common Ancestor of a Binary Search Tree[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>
<h3 id="description-22"><a class="markdownIt-Anchor" href="#description-22"></a> Description</h3>
<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<p>Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="img" /></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The LCA of nodes 2 and 8 is 6.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li>All of the nodes’ values will be unique.</li>
<li>p and q are different and both values will exist in the BST.</li>
</ul>
<h3 id="solution-22"><a class="markdownIt-Anchor" href="#solution-22"></a> Solution</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/</a></p>
<h2 id="236-lowest-common-ancestor-of-a-binary-treem"><a class="markdownIt-Anchor" href="#236-lowest-common-ancestor-of-a-binary-treem"></a> 236. Lowest Common Ancestor of a Binary Tree[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<h3 id="description-23"><a class="markdownIt-Anchor" href="#description-23"></a> Description</h3>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<p>Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img" /></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>All of the nodes’ values will be unique.</li>
<li>p and q are different and both values will exist in the binary tree.</li>
</ul>
<h3 id="solution-23"><a class="markdownIt-Anchor" href="#solution-23"></a> Solution</h3>
<h2 id="257-binary-tree-pathse"><a class="markdownIt-Anchor" href="#257-binary-tree-pathse"></a> 257. Binary Tree Paths[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-paths/">https://leetcode.com/problems/binary-tree-paths/</a></p>
<h3 id="description-24"><a class="markdownIt-Anchor" href="#description-24"></a> Description</h3>
<p>Given a binary tree, return all root-to-leaf paths.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br><span class="line"></span><br><span class="line">Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</span><br></pre></td></tr></table></figure>
<h3 id="solution-24"><a class="markdownIt-Anchor" href="#solution-24"></a> Solution</h3>
<h2 id="543-diameter-of-binary-treee"><a class="markdownIt-Anchor" href="#543-diameter-of-binary-treee"></a> 543. Diameter of Binary Tree[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/diameter-of-binary-tree/">https://leetcode.com/problems/diameter-of-binary-tree/</a></p>
<h3 id="description-25"><a class="markdownIt-Anchor" href="#description-25"></a> Description</h3>
<p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p>
<p><strong>Example:</strong><br />
Given a binary tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5    </span><br></pre></td></tr></table></figure>
<p>Return <strong>3</strong>, which is the length of the path [4,2,1,3] or [5,2,1,3].</p>
<p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p>
<h3 id="solution-25"><a class="markdownIt-Anchor" href="#solution-25"></a> Solution</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/diameter-of-binary-tree/solution/">https://leetcode.com/problems/diameter-of-binary-tree/solution/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        self.ans = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">depth</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            L = depth(node.left)</span><br><span class="line">            R = depth(node.right)</span><br><span class="line">            self.ans = max(self.ans, L+R+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> max(L, R) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        depth(root)</span><br><span class="line">        <span class="comment"># number of nodes - 1 = length</span></span><br><span class="line">        <span class="keyword">return</span> self.ans - <span class="number">1</span>      </span><br></pre></td></tr></table></figure>
<h2 id="617-merge-two-binary-treese"><a class="markdownIt-Anchor" href="#617-merge-two-binary-treese"></a> 617. Merge Two Binary Trees[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-binary-trees/">https://leetcode.com/problems/merge-two-binary-trees/</a></p>
<h3 id="description-26"><a class="markdownIt-Anchor" href="#description-26"></a> Description</h3>
<p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p>
<p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p>
<h3 id="solution-26"><a class="markdownIt-Anchor" href="#solution-26"></a> Solution</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-binary-trees/solution/">https://leetcode.com/problems/merge-two-binary-trees/solution/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, t1: TreeNode, t2: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> t1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        <span class="keyword">if</span> t2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        t1.val += t2.val</span><br><span class="line">        t1.left = self.mergeTrees(t1.left, t2.left)</span><br><span class="line">        t1.right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">        <span class="keyword">return</span> t1     </span><br></pre></td></tr></table></figure>
<h2 id="654-maximum-binary-treem"><a class="markdownIt-Anchor" href="#654-maximum-binary-treem"></a> 654. Maximum Binary Tree[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-binary-tree/">https://leetcode.com/problems/maximum-binary-tree/</a></p>
<h3 id="description-27"><a class="markdownIt-Anchor" href="#description-27"></a> Description</h3>
<p>Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:</p>
<ol>
<li>The root is the maximum number in the array.</li>
<li>The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.</li>
<li>The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.</li>
</ol>
<p>Construct the maximum tree by the given array and output the root node of this tree.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,6,0,5]</span><br><span class="line">Output: return the tree root node representing the following tree:</span><br><span class="line"></span><br><span class="line">      6</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     5</span><br><span class="line">    \    &#x2F; </span><br><span class="line">     2  0   </span><br><span class="line">       \</span><br><span class="line">        1</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>The size of the given array will be in the range [1,1000].</li>
</ol>
<h3 id="solution-27"><a class="markdownIt-Anchor" href="#solution-27"></a> Solution</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-binary-tree/solution/">https://leetcode.com/problems/maximum-binary-tree/solution/</a></p>
<h2 id="671-second-minimum-node-in-a-binary-treee"><a class="markdownIt-Anchor" href="#671-second-minimum-node-in-a-binary-treee"></a> 671. Second Minimum Node In a Binary Tree[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/divide-two-integers/">https://leetcode.com/problems/divide-two-integers/</a></p>
<h3 id="description-28"><a class="markdownIt-Anchor" href="#description-28"></a> Description</h3>
<p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly <code>two</code> or <code>zero</code> sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. More formally, the property <code>root.val = min(root.left.val, root.right.val)</code> always holds.</p>
<p>Given such a binary tree, you need to output the <strong>second minimum</strong> value in the set made of all the nodes’ value in the whole tree.</p>
<p>If no such second minimum value exists, output -1 instead.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    5   7</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The smallest value is 2, the second smallest value is 5.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"></span><br><span class="line">Output: -1</span><br><span class="line">Explanation: The smallest value is 2, but there isn&#39;t any second smallest value.</span><br></pre></td></tr></table></figure>
<h3 id="solution-28"><a class="markdownIt-Anchor" href="#solution-28"></a> Solution</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solution/">https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solution/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSecondMinimumValue</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        ans = float(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        min_val = root.val</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curr:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> min_val &lt; curr.val &lt; ans:</span><br><span class="line">                ans = curr.val</span><br><span class="line">            <span class="keyword">elif</span> curr.val == min_val:</span><br><span class="line">                stack.append(curr.left)</span><br><span class="line">                stack.append(curr.right)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt; float(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="number">-1</span>    </span><br></pre></td></tr></table></figure>
<h2 id="700-search-in-a-binary-search-treee"><a class="markdownIt-Anchor" href="#700-search-in-a-binary-search-treee"></a> 700. Search in a Binary Search Tree[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-a-binary-search-tree/">https://leetcode.com/problems/search-in-a-binary-search-tree/</a></p>
<h3 id="description-29"><a class="markdownIt-Anchor" href="#description-29"></a> Description</h3>
<p>Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node’s value equals the given value. Return the subtree rooted with that node. If such node doesn’t exist, you should return NULL.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given the tree:</span><br><span class="line">        4</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">And the value to search: 2</span><br></pre></td></tr></table></figure>
<p>You should return this subtree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2     </span><br><span class="line"> &#x2F; \   </span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<p>In the example above, if we want to search the value <code>5</code>, since there is no node with value <code>5</code>, we should return <code>NULL</code>.</p>
<p>Note that an empty tree is represented by <code>NULL</code>, therefore you would see the expected output (serialized tree format) as <code>[]</code>, not <code>null</code>.</p>
<h3 id="solution-29"><a class="markdownIt-Anchor" href="#solution-29"></a> Solution</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: int</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val == val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> root.val &gt; val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="101-symmetric-treee"><a class="markdownIt-Anchor" href="#101-symmetric-treee"></a> 101. Symmetric Tree[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/symmetric-tree/">https://leetcode.com/problems/symmetric-tree/</a></p>
<h3 id="description-30"><a class="markdownIt-Anchor" href="#description-30"></a> Description</h3>
<p>Share</p>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong> Solve it both recursively and iteratively.</p>
<h3 id="solution-30"><a class="markdownIt-Anchor" href="#solution-30"></a> Solution</h3>
<h2 id="208-implement-trie-prefix-treem"><a class="markdownIt-Anchor" href="#208-implement-trie-prefix-treem"></a> 208. Implement Trie (Prefix Tree)[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-trie-prefix-tree//">https://leetcode.com/problems/implement-trie-prefix-tree//</a></p>
<h3 id="description-31"><a class="markdownIt-Anchor" href="#description-31"></a> Description</h3>
<p>Implement a trie with <code>insert</code>, <code>search</code>, and <code>startsWith</code> methods.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; returns true</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; returns false</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; returns true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; returns true</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>You may assume that all inputs are consist of lowercase letters <code>a-z</code>.</li>
<li>All inputs are guaranteed to be non-empty strings.</li>
</ul>
<h3 id="solution-31"><a class="markdownIt-Anchor" href="#solution-31"></a> Solution</h3>
<h2 id="538-convert-bst-to-greater-treee"><a class="markdownIt-Anchor" href="#538-convert-bst-to-greater-treee"></a> 538. Convert BST to Greater Tree[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-bst-to-greater-tree/">https://leetcode.com/problems/convert-bst-to-greater-tree/</a></p>
<h3 id="description-32"><a class="markdownIt-Anchor" href="#description-32"></a> Description</h3>
<p>Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: The root of a Binary Search Tree like this:</span><br><span class="line">              5</span><br><span class="line">            &#x2F;   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">Output: The root of a Greater Tree like this:</span><br><span class="line">             18</span><br><span class="line">            &#x2F;   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> This question is the same as 1038: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/</a></p>
<h3 id="solution-32"><a class="markdownIt-Anchor" href="#solution-32"></a> Solution</h3>
<h2 id="572-subtree-of-another-treee"><a class="markdownIt-Anchor" href="#572-subtree-of-another-treee"></a> 572. Subtree of Another Tree[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subtree-of-another-tree/">https://leetcode.com/problems/subtree-of-another-tree/</a></p>
<h3 id="description-33"><a class="markdownIt-Anchor" href="#description-33"></a> Description</h3>
<p>Given two <strong>non-empty</strong> binary trees <strong>s</strong> and <strong>t</strong>, check whether tree <strong>t</strong> has exactly the same structure and node values with a subtree of <strong>s</strong>. A subtree of <strong>s</strong> is a tree consists of a node in <strong>s</strong> and all of this node’s descendants. The tree <strong>s</strong> could also be considered as a subtree of itself.</p>
<p><strong>Example 1:</strong><br />
Given tree s:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>
<p>Given tree t:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>
<p>Return <strong>true</strong>, because t has the same structure and node values with a subtree of s.</p>
<p><strong>Example 2:</strong><br />
Given tree s:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br><span class="line">   &#x2F;</span><br><span class="line">  0</span><br></pre></td></tr></table></figure>
<p>Given tree t:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>
<p>Return <strong>false</strong>.</p>
<h3 id="solution-33"><a class="markdownIt-Anchor" href="#solution-33"></a> Solution</h3>
<h2 id="872-leaf-similar-treese"><a class="markdownIt-Anchor" href="#872-leaf-similar-treese"></a> 872. Leaf-Similar Trees[E]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/leaf-similar-trees/">https://leetcode.com/problems/leaf-similar-trees/</a></p>
<h3 id="description-34"><a class="markdownIt-Anchor" href="#description-34"></a> Description</h3>
<p>Consider all the leaves of a binary tree. From left to right order, the values of those leaves form a <em>leaf value sequence.</em></p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" alt="img" /></p>
<p>For example, in the given tree above, the leaf value sequence is <code>(6, 7, 4, 9, 8)</code>.</p>
<p>Two binary trees are considered <em>leaf-similar</em> if their leaf value sequence is the same.</p>
<p>Return <code>true</code> if and only if the two given trees with head nodes <code>root1</code> and <code>root2</code> are leaf-similar.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>Both of the given trees will have between <code>1</code> and <code>200</code> nodes.</li>
<li>Both of the given trees will have values between <code>0</code> and <code>200</code></li>
</ul>
<h3 id="solution-34"><a class="markdownIt-Anchor" href="#solution-34"></a> Solution</h3>
<h2 id="116-populating-next-right-pointers-in-each-nodem"><a class="markdownIt-Anchor" href="#116-populating-next-right-pointers-in-each-nodem"></a> 116. Populating Next Right Pointers in Each Node[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">https://leetcode.com/problems/populating-next-right-pointers-in-each-node/</a></p>
<h3 id="description-35"><a class="markdownIt-Anchor" href="#description-35"></a> Description</h3>
<p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>You may only use constant extra space.</li>
<li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img" /></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the given tree is less than <code>4096</code>.</li>
<li><code>-1000 &lt;= node.val &lt;= 1000</code></li>
</ul>
<h3 id="solution-35"><a class="markdownIt-Anchor" href="#solution-35"></a> Solution</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="117-populating-next-right-pointers-in-each-node-iim"><a class="markdownIt-Anchor" href="#117-populating-next-right-pointers-in-each-node-iim"></a> 117. Populating Next Right Pointers in Each Node II[M]</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/</a></p>
<h3 id="description-36"><a class="markdownIt-Anchor" href="#description-36"></a> Description</h3>
<p>Given a binary tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>You may only use constant extra space.</li>
<li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt="img" /></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4,5,null,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,7,#]</span><br><span class="line">Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the given tree is less than <code>6000</code>.</li>
<li><code>-100 &lt;= node.val &lt;= 100</code></li>
</ul>
<h3 id="solution-36"><a class="markdownIt-Anchor" href="#solution-36"></a> Solution</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Joaxin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://u.pinsflora.com/Pysnista/Algor/D/leetcode_%20binary_tree/">https://u.pinsflora.com/Pysnista/Algor/D/leetcode_%20binary_tree/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/Leetcode/">Leetcode</a></div><div class="post_share"><div class="addtoany"><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_wechat"></a><a class="a2a_button_sina_weibo"></a><a class="a2a_button_facebook_messenger"></a><a class="a2a_button_email"></a><a class="a2a_button_copy_link"></a><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a></div></div><script async="async" src="https://static.addtoany.com/menu/page.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Pysnista/Algor/Strings/leetcode_Strings_simple/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/joaxin/img_bed/img/cover/cover_sea_stairs.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Leetcode - Strings Simple</div></div></a></div><div class="next-post pull-right"><a href="/Ruita/html/R_05_dates/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/joaxin/img_bed/img/cover_posts/r/R_time_universe.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">R Dates</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/Pysnista/Algor/Leetcode_Distance/" title="Leetcode - hamming"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-11-28</div><div class="title">Leetcode - hamming</div></div></a></div><div><a href="/Pysnista/Algor/Leetcode_Ranges/" title="Leetcode - Ranges"><img class="cover" src="https://cdn.jsdelivr.net/gh/joaxin/img_bed/img/cover/cover_forests.jpg"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-11-28</div><div class="title">Leetcode - Ranges</div></div></a></div><div><a href="/Pysnista/Algor/Leetcode_Reverse/" title="Leetcode - Reverse"><img class="cover" src="https://cdn.jsdelivr.net/gh/joaxin/img_bed/img/cover/cover_writing-letters-french.jpg"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-11-28</div><div class="title">Leetcode - Reverse</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div></div></div></div></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/joaxin/img_bed/img/cover/cover_stars_man_orchard_photos.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Joaxin</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Refine, the Life</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="fasle"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/fae45343.js","daovoice")
</script><script>var isChatBtn = true
daovoice('init', {
  app_id: 'fae45343',},{
  launcher: { 
     disableLauncherIcon: isChatBtn // 悬浮 ICON 是否显示
  },
});
daovoice('update');

if (isChatBtn) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      daovoice('show')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: true // 悬浮 ICON 是否显示
        },
      });
    }
    function chatBtnShow () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: false // 悬浮 ICON 是否显示
        },
      });
    }
  }
}</script></div></body></html>